
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Co Chat Interface</title>
  <link rel="stylesheet" href="comfy.css" />
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
</head>
<body>
  <div class="chat-container">
    <!-- Model selector node -->
    <div class="model-select-wrapper">
      <label for="model-select">MODEL</label>
      <select id="model-select"></select>
    </div>
    
    <!-- Main chat area with nodes -->
    <div class="chat-area">
      <!-- SVG for connection lines -->
      <svg class="connections" id="connections">
        <!-- Connection lines will be generated by JS -->
      </svg>
      
      <!-- Chat messages container -->
      <div class="chat-box" id="chat-box">
        <!-- Messages will be inserted here -->
      </div>
    </div>
    
    <!-- Stats node -->
    <div class="stats-bar">
      <div id="token-count">Tokens: 0 total (0 prompt, 0 completion)</div>
    </div>
    
    <!-- Input node -->
    <div class="input-area">
      <div class="input-row">
        <textarea id="chat-input" placeholder="Type your prompt here..."></textarea>
        <button id="send-btn">QUEUE PROMPT</button>
      </div>
    </div>
  </div>
  
  <script>
    // Helper function to create connection lines between nodes
    function updateConnections() {
      const svg = document.getElementById('connections');
      svg.innerHTML = ''; // Clear existing connections
      
      const messages = document.querySelectorAll('.message');
      
      for (let i = 0; i < messages.length - 1; i++) {
        const outputPoint = messages[i].querySelector('.connection-point.output');
        const inputPoint = messages[i+1].querySelector('.connection-point.input');
        
        if (outputPoint && inputPoint) {
          // Get points' positions
          const outputRect = outputPoint.getBoundingClientRect();
          const inputRect = inputPoint.getBoundingClientRect();
          const svgRect = svg.getBoundingClientRect();
          
          // Calculate positions relative to SVG
          const x1 = outputRect.left + outputRect.width/2 - svgRect.left;
          const y1 = outputRect.top + outputRect.height/2 - svgRect.top;
          const x2 = inputRect.left + inputRect.width/2 - svgRect.left;
          const y2 = inputRect.top + inputRect.height/2 - svgRect.top;
          
          // Create path with bezier curve
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          
          // Determine color based on message type
          let color = '#ffd700'; // Default yellow
          if (messages[i].classList.contains('user-message')) {
            color = '#ffd700'; // Yellow for user output
          } else {
            color = '#ff9955'; // Orange for bot output
          }
          
          // Create bezier curve path
          const dx = Math.abs(x2 - x1) * 0.7;
          path.setAttribute('d', `M${x1},${y1} C${x1+dx},${y1} ${x2-dx},${y2} ${x2},${y2}`);
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke', color);
          path.setAttribute('stroke-width', '2');
          path.setAttribute('stroke-dasharray', '5,5');
          path.style.animation = 'flowPulse 2s linear infinite';
          
          svg.appendChild(path);
        }
      }
    }
    
    // Function to create a message node
    function appendMessage(content, isUser = true) {
      const div = document.createElement('div');
      div.className = `message ${isUser ? 'user-message' : 'bot-message'}`;
      
      // Add connection points
      const outputPoint = document.createElement('div');
      outputPoint.className = 'connection-point output';
      div.appendChild(outputPoint);
      
      if (!isUser) {
        const inputPoint = document.createElement('div');
        inputPoint.className = 'connection-point input';
        div.appendChild(inputPoint);
      }
      
      // Message content
      div.innerHTML += content;
      
      document.getElementById('chat-box').appendChild(div);
      
      // Update connections after adding new node
      setTimeout(updateConnections, 50);
      
      // Scroll to bottom
      const chatBox = document.getElementById('chat-box');
      chatBox.scrollTop = chatBox.scrollHeight;
    }
    
    // Initialize with event listeners and fetch models
    window.addEventListener('load', function() {
      // Your existing code for model loading and event handlers
      // ...
      
      // Update connections on window resize
      window.addEventListener('resize', updateConnections);
    });
  </script>
  
  <script src="script.js"></script>
</body>
</html>